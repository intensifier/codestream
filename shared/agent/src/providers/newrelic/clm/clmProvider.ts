import { ClmManager } from "./clmManager";
import Cache from "@codestream/utils/system/timedCache";
import { ClmSpanData, isClmSpanData } from "../newrelic.types";
import {
	Entity,
	EntityAccount,
	GetClmRequest,
	GetClmRequestType,
	GetClmResponse,
	GetFileLevelTelemetryRequest,
	GetFileLevelTelemetryRequestType,
	GetFileLevelTelemetryResponse,
	GetMethodLevelTelemetryRequest,
	GetMethodLevelTelemetryRequestType,
	GetMethodLevelTelemetryResponse,
	isNRErrorResponse,
	MetricTimesliceNameMapping,
	NRErrorResponse,
	ObservabilityError,
	ObservabilityRepo,
} from "@codestream/protocols/agent";
import { isEmpty as _isEmpty } from "lodash";
import { lsp, lspHandler } from "../../../system/decorators/lsp";
import { log } from "../../../system/decorators/log";
import { ClmManagerNew } from "./clmManagerNew";
import { Logger } from "../../../logger";
import { Functions } from "../../../system/function";
import { generateClmSpanDataExistsQuery } from "../spanQuery";
import { NewRelicGraphqlClient } from "../newRelicGraphqlClient";
import { ReposProvider } from "../repos/reposProvider";
import { getMethodLevelTelemetryMockResponse } from "../anomalyDetectionMockResults";
import { NrApiConfig } from "../nrApiConfig";
import { GoldenSignalsProvider } from "../goldenSignals/goldenSignalsProvider";
import { DeploymentsProvider } from "../deployments/deploymentsProvider";
import {
	ErrorEventApiResponse,
	ObservabilityErrorsProvider,
} from "../errors/observabilityErrorsProvider";
import { mapNRErrorResponse, parseId } from "../utils";
import { ContextLogger } from "../../contextLogger";
import { Disposable } from "../../../system/disposable";
import { CriticalPathCalculator } from "../criticalPath";
import { ErrorTraceEventResponse, errorTraceToCommonError } from "../errors/errorQueries";

@lsp
export class ClmProvider implements Disposable {
	private _clmSpanDataExistsCache = new Cache<ClmSpanData>({
		defaultTtl: 120 * 1000,
	});
	private _clmTimedCache = new Cache<GetClmResponse>({
		defaultTtl: 120 * 1000,
	});
	constructor(
		private clmManager: ClmManager,
		private graphqlClient: NewRelicGraphqlClient,
		private reposProvider: ReposProvider,
		private nrApiConfig: NrApiConfig,
		private goldenSignalsProvider: GoldenSignalsProvider,
		private deploymentsProvider: DeploymentsProvider,
		private observabilityErrorsProvider: ObservabilityErrorsProvider
	) {}

	protected async findClmSpanDataExists(
		newRelicGuids: string[]
	): Promise<ClmSpanData[] | NRErrorResponse> {
		try {
			const results = await Promise.all(
				newRelicGuids.map(async _ => {
					const cached = this._clmSpanDataExistsCache.get(_);
					if (cached) {
						if (Logger.isDebugging) {
							Logger.debug(`findClmSpanDataExists ${JSON.stringify(cached)} from cache for ${_}`);
						}
						return cached;
					}
					const response = await this.graphqlClient.query(generateClmSpanDataExistsQuery(_), {
						accountId: parseId(_)?.accountId,
					});
					const spanData = response?.actor?.account?.nrql?.results[0];
					if (isClmSpanData(spanData)) {
						// Only cache valid results
						this._clmSpanDataExistsCache.put(_, spanData);
					}
					return spanData;
				})
			);

			return results;
		} catch (ex) {
			Logger.error(ex);
			return mapNRErrorResponse(ex);
		}
	}

	private async checkHasCodeLevelMetricSpanData(
		hasRepoAssociation: boolean,
		uniqueEntities: Entity[]
	): Promise<boolean | NRErrorResponse> {
		if (!hasRepoAssociation || _isEmpty(uniqueEntities)) {
			return false;
		}
		const repoEntitySpanDataExistsResponse = await this.findClmSpanDataExists(
			uniqueEntities?.map(_ => _.guid)
		);
		if (isNRErrorResponse(repoEntitySpanDataExistsResponse)) {
			return repoEntitySpanDataExistsResponse;
		}
		return repoEntitySpanDataExistsResponse?.find(_ => _ && _["entity.guid"] != null) != null;
	}

	private fltRequest: Promise<any> = Promise.resolve();
	@lspHandler(GetFileLevelTelemetryRequestType)
	@log()
	async getFileLevelTelemetry(
		request: GetFileLevelTelemetryRequest
	): Promise<GetFileLevelTelemetryResponse | NRErrorResponse | undefined> {
		await this.fltRequest;
		return (this.fltRequest = this.clmManager.getFileLevelTelemetry(request));
	}

	@lspHandler(GetMethodLevelTelemetryRequestType)
	@log()
	async getMethodLevelTelemetry(
		request: GetMethodLevelTelemetryRequest
	): Promise<GetMethodLevelTelemetryResponse | undefined> {
		const mockResponse = getMethodLevelTelemetryMockResponse(request);
		if (mockResponse) {
			return mockResponse;
		}

		let observabilityRepo: ObservabilityRepo | undefined;
		let entity: EntityAccount | undefined;
		let entityAccounts: EntityAccount[] = [];

		if (request.repoId) {
			observabilityRepo = await this.reposProvider.getObservabilityEntityRepos(request.repoId);
			if (!observabilityRepo || !observabilityRepo.entityAccounts) {
				return undefined;
			}
			entityAccounts = observabilityRepo.entityAccounts;

			entity = observabilityRepo.entityAccounts.find(
				_ => _.entityGuid === request.newRelicEntityGuid
			);
			if (!entity) {
				ContextLogger.warn("Missing entity", {
					entityId: request.newRelicEntityGuid,
				});
				return undefined;
			}
		}

		try {
			const goldenMetrics = await this.goldenSignalsProvider.getMethodLevelGoldenMetrics(
				request.newRelicEntityGuid || entity!.entityGuid!,
				request.metricTimesliceNameMapping,
				request.since,
				request.timeseriesGroup,
				request.scope
			);

			let deployments;
			if (request.includeDeployments && request.since) {
				deployments = (
					await this.deploymentsProvider.getDeployments({
						entityGuid: request.newRelicEntityGuid || entity!.entityGuid!,
						since: request.since,
					})
				).deployments;
			}

			const errors =
				request.includeErrors && request.metricTimesliceNameMapping
					? await this.getMethodLevelErrors(
							request.newRelicEntityGuid || entity!.entityGuid!,
							request.metricTimesliceNameMapping,
							observabilityRepo?.repoRemote || "",
							request.since,
							request.functionIdentifiers
					  )
					: [];

			const entityGuid = entity?.entityGuid || request.newRelicEntityGuid;
			const criticalPathCalculator = new CriticalPathCalculator(this.graphqlClient);
			const criticalPath = request.metricTimesliceNameMapping
				? await criticalPathCalculator.getCriticalPath(
						entityGuid,
						request.metricTimesliceNameMapping
				  )
				: undefined;

			const slowestQueries = await this.getSlowestQueries(
				request.metricTimesliceNameMapping?.duration,
				request.scope,
				entityGuid
			);

			return {
				goldenMetrics: goldenMetrics,
				deployments,
				criticalPath,
				errors,
				slowestQueries,
				newRelicEntityAccounts: entityAccounts,
				newRelicAlertSeverity: entity?.alertSeverity,
				newRelicEntityName: entity?.entityName || "",
				newRelicEntityGuid: entityGuid,
				newRelicUrl: `${this.nrApiConfig.productUrl}/redirect/entity/${entityGuid}`,
			};
		} catch (ex) {
			Logger.error(ex, "getMethodLevelTelemetry", {
				request,
			});
		}

		return undefined;
	}

	async getSlowestQueries(
		metricName: string | undefined,
		transactionName: string | undefined,
		entityGuid: string
	) {
		if (!metricName || !transactionName) return [];

		const parsedId = parseId(entityGuid)!;
		const slowestQueriesQuery =
			`FROM Span SELECT \`db.statement\` as statement, duration * 1000 as duration ` +
			`WHERE ` +
			`  entity.guid = '${entityGuid}' ` +
			`  AND name = '${metricName}' ` +
			`  AND db.statement IS NOT NULL ` +
			`  AND trace.id IN ( ` +
			`    FROM Transaction ` +
			`    SELECT uniques(traceId) ` +
			`    WHERE ` +
			`      name = '${transactionName}' ` +
			`      AND entity.guid = '${entityGuid}' ` +
			`    SINCE 30 minutes AGO LIMIT MAX ` +
			`  ) ` +
			`ORDER BY duration DESC SINCE 30 minutes ago LIMIT 10 `;

		const slowestQueries = await this.graphqlClient.runNrql<{
			statement: string;
			duration: number;
		}>(parsedId.accountId, slowestQueriesQuery);

		const formattedSlowestQueries = slowestQueries.map(query => {
			const statementParts = query.statement.split("*/");
			const statement = statementParts[statementParts.length - 1].trim();
			return {
				statement,
				duration: query.duration,
			};
		});

		return formattedSlowestQueries;
	}

	/**
	 * Get a list of recent error traces associated with a given method
	 *
	 * @param entityGuid entity guid for span data
	 * @param metricTimesliceNames names to use in the NRQL subquery
	 * @param remote the git remote for the error
	 * @param since value to use in the SINCE statement in the NRQL query
	 * @returns list of most recent error traces for each unique fingerprint
	 */
	@log()
	async getMethodLevelErrors(
		entityGuid: string,
		metricTimesliceNames: MetricTimesliceNameMapping,
		remote: string,
		since?: string,
		functionIdentifiers?: {
			codeNamespace?: string;
			functionName?: string;
			relativeFilePath?: string;
		}
	): Promise<ObservabilityError[]> {
		const parsedId = parseId(entityGuid)!;
		const query = this.getMethodLevelErrorsQuery(
			entityGuid,
			metricTimesliceNames,
			since,
			functionIdentifiers
		);
		if (!query) return [];

		const response = await this.graphqlClient.query<ErrorEventApiResponse<ErrorTraceEventResponse>>(
			`query fetchMethodLevelErrors($accountId:Int!) {
				actor {
					account(id: $accountId) {
						nrql(query: "${query}", timeout: 60) { nrql results }
					}
				}
			}`,
			{
				accountId: parsedId.accountId,
			}
		);
		const result = response.actor.account.nrql.results?.length
			? ((
					await Promise.all(
						response.actor.account.nrql.results.map(async errorTrace => {
							const response = await this.observabilityErrorsProvider.getErrorGroupDetails(
								errorTrace,
								"APM_APPLICATION_ENTITY"
							);

							const commonError = errorTraceToCommonError(errorTrace);

							if (response?.actor?.errorsInbox?.errorGroup) {
								return {
									entityId: commonError.entityGuid,
									appName: errorTrace.appName,
									errorClass: commonError.errorClass,
									message: commonError.message,
									remote: remote,
									errorGroupGuid: response.actor.errorsInbox.errorGroup.id,
									occurrenceId: commonError.occurrenceId,
									count: commonError.length,
									lastOccurrence: commonError.lastOccurrence,
									errorGroupUrl: response.actor.errorsInbox.errorGroup.url,
									traceId: commonError.traceId,
								};
							}
							return undefined;
						})
					)
			  ).filter(_ => _ !== undefined) as ObservabilityError[])
			: [];
		return result;
	}

	private getMethodLevelErrorsQuery(
		entityGuid: string,
		metricTimesliceNames?: MetricTimesliceNameMapping,
		since?: string,
		functionIdentifiers?: {
			codeNamespace?: string;
			functionName?: string;
			relativeFilePath?: string;
		}
	) {
		const transactionNameMatch = metricTimesliceNames?.errorRate?.match(/Errors\/(.*)/);
		if (
			(!transactionNameMatch || transactionNameMatch.length < 2) &&
			!functionIdentifiers?.functionName
		) {
			return undefined;
		}
		let transactionNameSubquery = "";
		if (transactionNameMatch && transactionNameMatch.length >= 2) {
			const transactionName = transactionNameMatch[1];
			transactionNameSubquery = [
				"(",
				`transactionName = '${transactionName}'`,
				"AND",
				`entityGuid = '${entityGuid}'`,
				")",
			].join(" ");
		}
		since = since || "30 minutes ago";
		let codeClause = "";
		let spanSubquery = "";
		if (functionIdentifiers?.functionName) {
			codeClause = `code.function = '${functionIdentifiers.functionName}'`;
			const codeClauseSubClauses = [];
			if (functionIdentifiers.codeNamespace) {
				codeClauseSubClauses.push(`code.namespace = '${functionIdentifiers.codeNamespace}'`);
			}
			if (functionIdentifiers.relativeFilePath) {
				codeClauseSubClauses.push(`code.filepath = '${functionIdentifiers.relativeFilePath}'`);
			}
			if (codeClauseSubClauses.length > 0) {
				codeClause += ` AND (${codeClauseSubClauses.join(" OR ")})`;
			}
			spanSubquery =
				functionIdentifiers && functionIdentifiers.functionName
					? [
							"guid IN (",
							"SELECT",
							"transactionId",
							"FROM Span",
							`WHERE entity.guid = '${entityGuid}'`,
							"WHERE (",
							"error.class IS NOT NULL",
							"OR",
							"error.group.guid",
							")",
							"AND (",
							codeClause,
							")",
							")",
					  ].join(" ")
					: "";
		}
		const whereClause = [transactionNameSubquery, spanSubquery].filter(_ => _ !== "").join(" OR ");
		return [
			"SELECT",
			"count(id) AS 'length',", // first field is used to sort with FACET
			"latest(timestamp) AS 'timestamp',",
			"latest(id) AS 'id',",
			"latest(appName) AS 'appName',",
			"latest(error.class) AS 'error.class',",
			"latest(error.message) AS 'error.message',",
			"latest(entityGuid) AS 'entityGuid',",
			"latest(traceId) AS 'traceId'",
			"FROM ErrorTrace",
			"WHERE ",
			whereClause,
			"WHERE fingerprint IS NOT NULL",
			"FACET error.class, message",
			`SINCE ${since}`,
			"LIMIT 10",
		].join(" ");
	}

	@lspHandler(GetClmRequestType)
	@log()
	async getClm(request: GetClmRequest): Promise<GetClmResponse> {
		const cached = this._clmTimedCache.get(request);
		if (cached) {
			return cached;
		}

		let lastEx;
		const fn = async () => {
			try {
				const clmExperiment = new ClmManagerNew(request, this.graphqlClient, this.reposProvider);
				const result = await clmExperiment.execute();
				this._clmTimedCache.put(request, result);
				return true;
			} catch (ex) {
				Logger.warn(ex.message);
				lastEx = ex.message;
				return false;
			}
		};
		await Functions.withExponentialRetryBackoff(fn, 5, 1000);
		const response = this._clmTimedCache.get(request) || {
			codeLevelMetrics: [],
			isSupported: false,
			error: lastEx,
		};

		return response;
	}

	/*
	Not actually used - agent is restarted at logout but keeping for
	possible future use
  */
	dispose(): void {
		this._clmSpanDataExistsCache.clear();
		this._clmTimedCache.clear();
	}
}
